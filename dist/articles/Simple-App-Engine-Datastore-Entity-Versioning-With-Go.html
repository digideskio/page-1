<html><head><meta http-equiv="content-type" content="text/html;charset=utf-8"/><title>Simple App Engine Datastore Entity Versioning With Go | Timm Preetz</title><style>
      
    body {
        background-color: #ededed;
      }
      .contentWrapper {
        padding: 0 20px;
      }
      nav {
        /* 
        background-color: #313131 !important;
        position: fixed !important; */
      }
    
      
    
      body {
        font-family: "Avenir Next", "Segoe UI", "Helvetica Neue", sans-serif;
        font-weight: 400; /* TODO: use 200 for Helvetica Neue */
        font-size: 18px;
        margin: 0;
      }
    
  
    
      blockquote {
        margin-left: 0.25em;
        padding: 0px 1em 0px 1em;
        border-left: 1px solid #c0c0c0;
      }
    
      #mainWrapper {
        max-width: 900px;
        margin: auto;
        display: flex;
        flex-direction: column;
    
        margin-top: 40px;
        overflow-x: hidden;
    
        /*
        position: fixed;
        top: 40px;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: scroll;
        */
      }
    
      @media only all and (min-width: 415px) {
        #mainWrapper {
          padding: 0 15px;
        }
      }
    
      nav {
        padding: 0 20px;
        height: 40px;
        max-width: 900px;
        display: flex;
        flex-basis: 0;
        flex-grow: 1;
      }
    
      nav a {
        color: #313131;
        font-family: Futura;
        text-decoration: none;
        line-height: 40px;
      }
    
      nav a:hover {
        text-decoration: underline;
      }
    
      div.sbs {
        display: flex;
      }
    
      div.sbs > div {
        flex-grow: 1;  flex-basis: 0;
      }
    
      @media (max-width: 640px) {
        div.sbs {
          flex-direction: column;
        }
      }
    
      .recentPosts h1 {
        line-height: 1em;
        padding: 0px;
        margin: 0em 0;
      }
    
      .recentPosts a.postTitle {
        color: #313131;
        font-weight: 400;
        text-decoration: none;
      }
    
      .recentPosts a.postTitle:hover {
        text-decoration: underline;
      }
    
      .recentPosts hr {
        margin: 50px 0;
      }
    
      .recentPosts span {
        color: #313131;
        /* font-family: Courier, monospace; */
        font-weight: 400;
        font-size: 12px;
      }
    
      a, a:visited, a:hover, a:active {
        color: #313131;
      }
    
      a:hover {
        text-decoration: none;
      }
    
      hr {
        background-color: #bfbfbf;
        border: 0;
        height: 1px;
      }
    
      .homepageOverview {
        border-radius: 5px 5px 0 0; 
        padding: 20px;
      }
    
      #navWrapper {
        position: fixed;
        top: 0;
        height: 40px;
        left: 0;
        right: 0;
        display: flex;
        background-color: rgba(255,255,255,0.65);
        -webkit-backdrop-filter: blur(7px);
        z-index: 1;
        justify-content: center;
      }
    
      sup[id^=fnref] {
        padding-top: 40px;
        margin-top: -40px;
      }
    
      img {
        max-width: 100%;
      }</style><link rel="stylesheet" href="/assets/highlightjs.css"/></head><body><div id="navWrapper"><nav><a href="/" style="margin-right:20px"><img src="/assets/ava.jpg" width="30" height="30" style="margin-top:5px;float:left;border-radius:2px"/></a><a href="/projects">Projects</a>      <a href="/archive">Archive</a>      <a href="/about">About</a></nav></div><div id="mainWrapper"><div class="contentWrapper"><div><h1>Simple App Engine Datastore Entity Versioning With Go</h1>
<p>In a recent project we needed the ability to save every version of a <code>User</code>'s profile (type <code>UserProfile</code>) in our database, so that we are able track changes over time and restore or review previous versions.</p>
<p>Since there does not seem to be a standard way to do entity versioning with App Engine Datastore entities, I wrote up a quick sample below of how I solved this.</p>
<p>I think there are two basically two way to achieve this whithout data normalization (i.e. storing the latest version in a special place):</p>
<ul>
<li>Store an ever increasing version number with the entities. Pick the one with the highest version number when querying. Optionally this can be used to only allow successive saves (from version 3 to 4 to 5 etc.).</li>
<li>Store the creation/save date with each entity. Pick the entity with the most recent creation date when querying.</li>
</ul>
<p>(I won't delve into <a href="http://en.wikipedia.org/wiki/Delta_encoding">delta compression</a> here, which may be worth considering if your entities are sufficiently large or change a lot.)</p>
<p>I opted for a solution based on the entity creation time instead of a entity versioning solution that requires successive entities versions since those can be created without reading the previous entities' version number from the <code>datastore</code>.</p>
<p>This also has the benefit that we’re able to restore the state of the whole database for any point in time since all changing entities are tagged with their creation date.</p>
<p>And because writes to a single entity group (in our case the <code>User</code>) are strongly consistend and <a href="https://cloud.google.com/appengine/docs/go/datastore/#Go_Datastore_writes_and_data_visibility">guaranteed to be executed before the next read</a> of entities in that group, we are always seeing the most recently created <code>UserProfile</code> in our queries.</p>
<h2>Implemenation &amp; Tests</h2>
<p>main.go</p>
<pre><code class="language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"fmt"</span>
	<span class="hljs-string">"time"</span>

	<span class="hljs-string">"appengine"</span>
	<span class="hljs-string">"appengine/datastore"</span>
)

<span class="hljs-keyword">const</span> (
	KindUser        = <span class="hljs-string">"user"</span>
	KindUserProfile = <span class="hljs-string">"userprofile"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {}

<span class="hljs-keyword">type</span> CreatedAtStruct <span class="hljs-keyword">struct</span> {
	CreatedAt time.Time
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *CreatedAtStruct)</span> <span class="hljs-title">SetCreatedAt</span><span class="hljs-params">(t time.Time)</span></span> {
	c.CreatedAt = t
}

<span class="hljs-keyword">type</span> CreationDateSetter <span class="hljs-keyword">interface</span> {
	SetCreatedAt(t time.Time)
}

<span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span>{}

<span class="hljs-keyword">type</span> UserProfile <span class="hljs-keyword">struct</span> {
	CreatedAtStruct

	Counter <span class="hljs-keyword">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">putVersioned</span><span class="hljs-params">(c appengine.Context, kind <span class="hljs-keyword">string</span>, parent *datastore.Key, v CreationDateSetter)</span> <span class="hljs-params">(*datastore.Key, error)</span></span> {
	<span class="hljs-keyword">if</span> parent == <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">"parent must be set"</span>)
	}

	v.SetCreatedAt(time.Now())

	<span class="hljs-keyword">return</span> datastore.Put(c, datastore.NewIncompleteKey(c, kind, parent), v)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getLatest</span><span class="hljs-params">(c appengine.Context, kind <span class="hljs-keyword">string</span>, parent *datastore.Key, v <span class="hljs-keyword">interface</span>{})</span> <span class="hljs-title">error</span></span> {
	q := datastore.NewQuery(kind).Ancestor(parent).Order(<span class="hljs-string">"-CreatedAt"</span>).Limit(<span class="hljs-number">1</span>)

	_, err := q.Run(c).Next(v)

	<span class="hljs-keyword">return</span> err
}
</code></pre>
<p>main_test.go</p>
<pre><code class="language-go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">"testing"</span>

	<span class="hljs-string">"appengine/aetest"</span>
	<span class="hljs-string">"appengine/datastore"</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestVersionedStorageAfterEachPut</span><span class="hljs-params">(t *testing.T)</span></span> {
	c, err := aetest.NewContext(<span class="hljs-literal">nil</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		t.Fatal(err)
	}

	userkey, err := datastore.Put(c, datastore.NewIncompleteKey(c, KindUser, <span class="hljs-literal">nil</span>), &amp;User{})
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		t.Fatal(err)
	}

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ {
		p := &amp;UserProfile{Counter: i}
		_, err := putVersioned(c, KindUserProfile, userkey, p)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			t.Fatal(err)
		}

		outputProfile := <span class="hljs-built_in">new</span>(UserProfile)
		err = getLatest(c, KindUserProfile, userkey, outputProfile)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			t.Fatal(err)
		}

		<span class="hljs-keyword">if</span> outputProfile.Counter != i {
			t.Fatalf(<span class="hljs-string">"Expected Counter to be %d but it was %d"</span>, i, outputProfile.Counter)
		}
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestVersionedStorageAfterAllPuts</span><span class="hljs-params">(t *testing.T)</span></span> {
	c, err := aetest.NewContext(<span class="hljs-literal">nil</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		t.Fatal(err)
	}

	userkey, err := datastore.Put(c, datastore.NewIncompleteKey(c, KindUser, <span class="hljs-literal">nil</span>), &amp;User{})
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		t.Fatal(err)
	}

	upper := <span class="hljs-number">10</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= upper; i++ {
		p := &amp;UserProfile{Counter: i}
		_, err := putVersioned(c, KindUserProfile, userkey, p)
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
			t.Fatal(err)
		}
	}

	outputProfile := <span class="hljs-built_in">new</span>(UserProfile)
	err = getLatest(c, KindUserProfile, userkey, outputProfile)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		t.Fatal(err)
	}

	<span class="hljs-keyword">if</span> outputProfile.Counter != upper {
		t.Fatalf(<span class="hljs-string">"Expected Counter to be %d but it was %d"</span>, upper, outputProfile.Counter)
	}
}
</code></pre>
<p><a href="https://gist.github.com/tp/c1e25ae24d405a58f081">See Gist on GitHub</a></p>
</div></div></div></body></html>
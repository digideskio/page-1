<html><head><meta http-equiv="content-type" content="text/html;charset=utf-8"/><title>TypeScript: `ReturnType` for `async` `function`s | Timm Preetz</title><style>
      
    body {
        background-color: #ededed;
      }
      .contentWrapper {
        padding: 0 20px;
      }
      nav {
        /* 
        background-color: #313131 !important;
        position: fixed !important; */
      }
    
      
    
      body {
        font-family: "Avenir Next", "Segoe UI", "Helvetica Neue", sans-serif;
        font-weight: 400; /* TODO: use 200 for Helvetica Neue */
        font-size: 18px;
        margin: 0;
      }
    
  
    
      blockquote {
        margin-left: 0.25em;
        padding: 0px 1em 0px 1em;
        border-left: 1px solid #c0c0c0;
      }
    
      #mainWrapper {
        max-width: 900px;
        margin: auto;
        display: flex;
        flex-direction: column;
    
        margin-top: 40px;
        overflow-x: hidden;
    
        /*
        position: fixed;
        top: 40px;
        left: 0;
        right: 0;
        bottom: 0;
        overflow: scroll;
        */
      }
    
      @media only all and (min-width: 415px) {
        #mainWrapper {
          padding: 0 15px;
        }
      }
    
      nav {
        padding: 0 20px;
        height: 40px;
        max-width: 900px;
        display: flex;
        flex-basis: 0;
        flex-grow: 1;
      }
    
      nav a {
        color: #313131;
        font-family: Futura;
        text-decoration: none;
        line-height: 40px;
      }
    
      nav a:hover {
        text-decoration: underline;
      }
    
      div.sbs {
        display: flex;
      }
    
      div.sbs > div {
        flex-grow: 1;  flex-basis: 0;
      }
    
      @media (max-width: 640px) {
        div.sbs {
          flex-direction: column;
        }
      }
    
      .recentPosts h1 {
        line-height: 1em;
        padding: 0px;
        margin: 0em 0;
      }
    
      .recentPosts a.postTitle {
        color: #313131;
        font-weight: 400;
        text-decoration: none;
      }
    
      .recentPosts a.postTitle:hover {
        text-decoration: underline;
      }
    
      .recentPosts hr {
        margin: 50px 0;
      }
    
      .recentPosts span {
        color: #313131;
        /* font-family: Courier, monospace; */
        font-weight: 400;
        font-size: 12px;
      }
    
      a, a:visited, a:hover, a:active {
        color: #313131;
      }
    
      a:hover {
        text-decoration: none;
      }
    
      hr {
        background-color: #bfbfbf;
        border: 0;
        height: 1px;
      }
    
      .homepageOverview {
        border-radius: 5px 5px 0 0; 
        padding: 20px;
      }
    
      #navWrapper {
        position: fixed;
        top: 0;
        height: 40px;
        left: 0;
        right: 0;
        display: flex;
        background-color: rgba(255,255,255,0.65);
        -webkit-backdrop-filter: blur(7px);
        z-index: 1;
        justify-content: center;
      }
    
      sup[id^=fnref] {
        padding-top: 40px;
        margin-top: -40px;
      }
    
      img {
        max-width: 100%;
      }</style><link rel="stylesheet" href="/assets/highlightjs.css"/></head><body><div id="navWrapper"><nav><a href="/" style="margin-right:20px"><img src="/assets/ava.jpg" width="30" height="30" style="margin-top:5px;float:left;border-radius:2px"/></a><a href="/projects">Projects</a>      <a href="/archive">Archive</a>      <a href="/about">About</a></nav></div><div id="mainWrapper"><div class="contentWrapper"><div><h1>TypeScript: <code>ReturnType</code> for <code>async</code> <code>function</code>s</h1>
<p>Since the introduction of the <code>ReturnType</code> in <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-8.html">TypeScript 2.8</a>, we can build up types based on the results of functions, without mentioning the types explicitly:</p>
<pre><code class="language-ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createContext</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> (<span class="hljs-params"></span>) =&gt; <span class="hljs-title">any</span>&gt;(<span class="hljs-params">configProvider: T</span>): </span>{ config: ReturnType&lt;T&gt; } {
    <span class="hljs-keyword">return</span> {
        config: configProvider(),
    }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">apiConfig</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> {
        endpoint: <span class="hljs-string">'https://www.example.com'</span>
    }
}

<span class="hljs-comment">/**
 * context has type `{ config: { endpoint: string; }; }`
 */</span>
<span class="hljs-keyword">const</span> context =  createContext(apiConfig);
</code></pre>
<p><a href="https://www.typescriptlang.org/play/#src=%0D%0A%0D%0Afunction%20createContext%3CT%20extends%20()%20%3D%3E%20any%3E(configProvider%3A%20T)%3A%20%7B%20config%3A%20ReturnType%3CT%3E%20%7D%20%7B%0D%0A%20%20%20%20return%20%7B%0D%0A%20%20%20%20%20%20%20%20config%3A%20configProvider()%2C%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0Afunction%20apiConfig()%20%7B%0D%0A%20%20%20%20return%20%7B%0D%0A%20%20%20%20%20%20%20%20endpoint%3A%20'https%3A%2F%2Fwww.example.com'%0D%0A%20%20%20%20%7D%0D%0A%7D%0D%0A%0D%0A%2F**%0D%0A%20*%20context%20has%20type%20%60%7B%20config%3A%20%7B%20endpoint%3A%20string%3B%20%7D%3B%20%7D%60%0D%0A%20*%2F%0D%0Aconst%20context%20%3D%20%20createContext(apiConfig)">Playground</a></p>
<p>Now that <code>async</code> functions are becoming more prevalent in the code I work with, I have been wondering whether a similar helper can be employed to get the type of a successfully resolved <code>Promise</code>.</p>
<p>As a first building block I wrote a type to extract the <code>Promise</code>'s resolved type:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> PromiseResolvedType&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;infer R&gt; ? R : never;

<span class="hljs-comment">// Type is currently Promise&lt;number&gt;</span>
<span class="hljs-keyword">const</span> promise = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);

<span class="hljs-comment">// value has type `number`, will stay in sync with type of `promise` variable</span>
<span class="hljs-keyword">let</span> comparisionValue: PromiseResolvedType&lt;<span class="hljs-keyword">typeof</span> promise&gt; = <span class="hljs-number">5</span>;

promise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Value equal to comparison?`</span>, value === comparisionValue));
</code></pre>
<p><a href="https://www.typescriptlang.org/play/#src=type%20PromiseResolvedType%3CT%3E%20%3D%20T%20extends%20Promise%3Cinfer%20R%3E%20%3F%20R%20%3A%20never%3B%0D%0A%0D%0A%2F%2F%20Type%20is%20currently%20Promise%3Cnumber%3E%0D%0Aconst%20promise%20%3D%20Promise.resolve(3)%3B%0D%0A%0D%0A%2F%2F%20value%20has%20type%20%60number%60%2C%20will%20stay%20in%20sync%20with%20%60promise%60%20variable%0D%0Alet%20comparisionValue%3A%20PromiseResolvedType%3Ctypeof%20promise%3E%20%3D%205%3B%0D%0A%0D%0Apromise.then(value%20%3D%3E%20console.log(%60Value%20equal%20to%20comparison%3F%60%2C%20value%20%3D%3D%3D%20comparisionValue))%3B">Playground</a></p>
<p>That works nicely to limit our comparision value to the same type as the <code>Promise</code> instance might eventually resolve to. That way we can ensure consistency. If the types were not matching, the comparison will definitely fail, so we get faster feedback by moving that first check to the compile time of the program.</p>
<p>The final step is now to return the <code>ReturnType</code> with the <code>PromiseResolvedType</code> to access the success value of a Promise returned by a function:</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> PromiseResolvedType&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Promise</span>&lt;infer R&gt; ? R : never;
<span class="hljs-keyword">type</span> ReturnedPromiseResolvedType&lt;T&gt; = PromiseResolvedType&lt;ReturnType&lt;T&gt;&gt;
<span class="hljs-comment">// or flattened: type ReturnedPromiseResolvedType&lt;T&gt; = T extends (...args: any[]) =&gt; Promise&lt;infer R&gt; ? R : never;</span>

<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random</span>(<span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt; </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random();
}

<span class="hljs-keyword">type</span> RandomFuncResolvedType = ReturnedPromiseResolvedType&lt;<span class="hljs-keyword">typeof</span> random&gt;; <span class="hljs-comment">// number</span>
</code></pre>
<p><a href="https://www.typescriptlang.org/play/#src=type%20PromiseResolvedType%3CT%3E%20%3D%20T%20extends%20Promise%3Cinfer%20R%3E%20%3F%20R%20%3A%20never%3B%0D%0Atype%20ReturnedPromiseResolvedType%3CT%3E%20%3D%20PromiseResolvedType%3CReturnType%3CT%3E%3E%0D%0A%2F%2F%20or%20flattened%3A%20type%20ReturnedPromiseResolvedType%3CT%3E%20%3D%20T%20extends%20(...args%3A%20any%5B%5D)%20%3D%3E%20Promise%3Cinfer%20R%3E%20%3F%20R%20%3A%20never%3B%0D%0A%0D%0Aasync%20function%20random()%3A%20Promise%3Cnumber%3E%20%7B%0D%0A%20%20return%20Math.random()%3B%0D%0A%7D%0D%0A%0D%0Atype%20RandomFuncResolvedType%20%3D%20ReturnedPromiseResolvedType%3Ctypeof%20random%3E%3B%20%2F%2F%20number">Playground</a></p>
</div></div></div></body></html>
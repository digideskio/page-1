<hr />
<h2>title: Using RubaXa Sortable with Ember.js
layout: default</h2>
<!-- raw HTML omitted -->
<p><a href="http://rubaxa.github.io/Sortable/">Sortable by RubaXA</a> is a great library for visually sorting elements in HTML apps.
Sadly it has <a href="https://github.com/RubaXa/Sortable/issues/175">no built-in support for Ember.js</a>, so I thought I would elaborate here how I added it to a client's <a href="http://emberjs.com/">Ember.js</a> app.</p>
<h2>Creating a SortableList component</h2>
<p>app/components/sortable-list.js:</p>
<pre><code class="language-js">import Ember from 'ember';
import Sortable from 'npm:sortablejs'; // this requires Ember CLI with ember-browserify, which is great!

export default Ember.Component.extend({
  init: function() {
    this._super();

    Ember.assert('required `viewModels` param is set', !Ember.isNone(this.get('viewModels')));
  },
  tagName: 'ul',
  classNames: ['sortableList'],
  actions: {
    removeItem: function(index) {
      this.sendAction('removeItem', index);
    }
  },
  didInsertElement: function() {
    console.debug('Setup Sortable in didInsertElement');

    let s = Sortable.create(document.getElementById(this.get('elementId')), {
      draggable: &quot;.sortableTopicListItem&quot;,
      onSort: (evt) =&gt; {
        if (evt.type !== 'sort') {
          console.debug('Skipping event that is not sort.')
          return;
        }

        if (evt.oldIndex === evt.newIndex) {
          console.debug('NOOP, evt.oldIndex === evt.newIndex; not sending action; not removing element');
          return;
        }

        console.debug(`evt.oldIndex = ${evt.oldIndex} -&gt; evt.newIndex = ${evt.newIndex}`);

        let dragItem = evt.item;
        dragItem.parentNode.removeChild(dragItem);

        this.sendAction('itemMoved', evt.oldIndex, evt.newIndex);
      },
    });

    this.set('Sortable', s); // for later destruction
  },
  willDestroyElement: function() {
    console.debug('destroying Sortable in willDestroyElement');
    this.get('Sortable').destroy();
  }
});
</code></pre>
<p>app/templates/components/sortable-list.hbs:</p>
<pre><code class="language-handlebars">{% raw %}
{{#each viewModels as |viewModel index| }}
  &lt;li class=&quot;sortableTopicListItem&quot;&gt;
    {{viewModel.displayName}}
    &lt;i {{action removeItem index}} class=&quot;remove&quot;&gt;âœ–&lt;/i&gt;
  &lt;/li&gt;
{{/each}}
{% endraw %}
</code></pre>
<h2>Using the SortableList component</h2>
<p>Showing items with a SortableList is now very easy. All you have to do is supply some <code>viewModels</code> which have <code>displayName</code> property.</p>
<pre><code class="language-handlebars">{% raw %}
{{sortable-list viewModels=viewModels itemMoved='moveItem' removeItem='removeItem'}}
{% endraw %}
</code></pre>
<p>It get's a little more complicated, when you want to reflect the actions that took place in the DOM in your internal data model.</p>
<p>For this the work the enclosing component has to implement <code>moveItem</code> and <code>removeItem</code> actions where it recreates the changes in it's internal store.</p>
<p>This is the relevant part from one of my enclosing components:</p>
<pre><code class="language-js">actions: {
  moveItem: function(oldIndex, newIndex) {
    Ember.assert('required `oldIndex` param is set', !Ember.isNone(oldIndex));
    Ember.assert('required `newIndex` param is set', !Ember.isNone(newIndex));

    console.debug(`oldIndex = ${oldIndex} -&gt; newIndex = ${newIndex}`);

    let references = this.get('value'); // Your underlying array

    let movingReference = references.objectAt(oldIndex);

    references.removeAt(oldIndex, 1);
    references.insertAt(newIndex, movingReference);
  },
  removeItem: function(index) {
    Ember.assert('required `index` param is set', !Ember.isNone(index));

    let references = this.get('value');
    references.removeAt(index, 1);
  }
}
</code></pre>
<p>I hope this is helpful for everyone looking to solve a similar problem.</p>
